# Flask路由（Route）

## Flask返回值规则
1. 只返回响应体（默认状态码 200） 
   `return {'message': 'success'}  # HTTP 状态码自动设为 200`
2. 返回元组（响应体, 状态码）
   `return {'error': 'not found'}, 404  # 明确指定状态码为 404`
3. 返回三元组（响应体, 状态码, 响应头）
   `return {'error': 'not found'}, 404, {'X-Custom': 'value'}  # 指定响应头`

## 响应处理机制

Flask 的处理流程：
1. 检测返回值类型
2. 如果是字典 → 自动转换为 JSON
3. 自动设置 Content-Type: application/json
4. 返回给客户端

### Flask 对不同返回类型的处理
1. 字典（dict）→ 自动 JSON 化
2. 列表（list）→ 自动 JSON 化
3. 字符串（str）→ 直接返回
4. 元组 → 特殊处理

### 底层实现原理
Flask 使用 jsonify() 函数来处理字典和列表：
```python
from flask import jsonify

@app.get("/health")
def health():
    return jsonify({"status": "ok"})
```

jsonify() 做了以下几件事：
1. 将 Python 对象转换为 JSON 字符串
2. 创建 Response 对象
3. 设置 Content-Type: application/json
4. 设置正确的字符编码

---

## 错误处理

```python
@app.errorhandler(HTTPException)
def handle_http_exception(e: HTTPException):
  return {
    'error': 'http_error',
    'status': e.code,
    'name': e.name,
    'path': request.path,
  }, e.code
```

- 全局路由错误处理 
- HTTPException： Werkzeug 的 HTTP 异常基类（如 404、500）
- 效果：当应用抛出 HTTP 异常时，会自动调用这个函数处理

### 工作原理
当 Flask 应用发生 HTTP 错误时：
1. 触发错误：例如访问不存在的路由（404）
2. 捕获异常：@app.errorhandler 捕获 HTTPException
3. 调用处理函数：执行 handle_http_exception
4. 返回统一格式：返回 JSON 格式的错误信息

---

## Flask 钩子函数

Flask 提供了多个钩子函数：

| 钩子函数 | 执行时机 | 用途 |
|---------|---------|------|
| `@app.before_request` | 每个请求处理前 | 身份验证、数据预处理 |
| `@app.after_request` | 每个请求处理后 | 日志记录、响应修改 |
| `@app.teardown_request` | 请求结束后 | 清理资源 |
| `@app.errorhandler` | 发生错误时 | 错误处理 |

```python
@app.before_request
def before_request():
  logging.info(f"Request: {request.method} {request.path}")
```

- 效果：每个请求处理前都会执行 before_request 函数
---

## request.get_json()

```python
@app.route('/echo', methods=['POST'])
def echo():
  data = request.get_json()
  return jsonify(data)
```

- 作用：解析请求体中的 JSON 数据
- 前提：请求的 Content-Type 为 application/json
- 返回：解析后的 Python 字典或列表

### 参数
- silent=True 
  - 作用：静默处理错误
  - 行为：
    - 成功：返回解析后的 JSON 数据
    - 失败：返回 None（而不是抛出异常）
- force=True
  - 作用：强制解析请求体中的 JSON 数据
  - 行为：
    - 成功：返回解析后的 JSON 数据
    - 失败：返回 None（而不是抛出异常）
- cache=False
  - 作用：不缓存（每次都重新解析）数据

---


## Flask `make_response` 详细说明

### 基本语法
```python
from flask import make_response

resp = make_response(response, status=None, headers=None)
```

### 参数说明
| 参数 | 类型 | 说明 | 必需 |
|------|------|------|------|
| `response` | 任意 | 响应内容（字符串、字典、列表等） | ✅ |
| `status` | int | HTTP 状态码（如 200, 404, 500） | ❌ |
| `headers` | dict | 响应头字典 | ❌ |

### 返回值
返回 `Response` 对象（Werkzeug 的 `Response` 类实例）

---

### 基本用法示例

#### 示例1：最简单的用法
```python
@app.route('/simple')
def simple():
    resp = make_response("Hello World")
    return resp
# 等同于：return "Hello World"
```

#### 示例2：指定状态码
```python
@app.route('/created')
def created():
    resp = make_response({"id": 1, "name": "John"}, 201)
    return resp
# 等同于：return {"id": 1, "name": "John"}, 201
```

#### 示例3：设置响应头
```python
@app.route('/with-header')
def with_header():
    resp = make_response({"data": "ok"}, 200)
    resp.headers["X-Custom-Header"] = "value"
    return resp
```

#### 示例4：一次性设置多个响应头
```python
@app.route('/multiple-headers')
def multiple_headers():
    resp = make_response({"data": "ok"}, 200, {
        "X-Header-1": "value1",
        "X-Header-2": "value2"
    })
    return resp
```

---

### Response 对象的常用属性和方法

#### 属性

1. `resp.status_code` - 状态码
```python
resp = make_response("OK", 200)
print(resp.status_code)  # 200

resp.status_code = 404  # 可以修改
```

2. `resp.headers` - 响应头（类似字典）
```python
resp = make_response("OK")
resp.headers["Content-Type"] = "application/json"
resp.headers["X-Custom"] = "value"

# 访问响应头
print(resp.headers["X-Custom"])  # "value"
```

3. `resp.data` - 响应数据（字节）
```python
resp = make_response("Hello")
print(resp.data)  # b'Hello'
```

4. `resp.content_type` - Content-Type
```python
resp = make_response("OK")
resp.content_type = "application/json"
```

#### 方法

1. `resp.set_cookie()` - 设置 Cookie
```python
resp = make_response("OK")
resp.set_cookie(
    'username',           # Cookie 名称
    'john',               # Cookie 值
    max_age=3600,         # 过期时间（秒）
    secure=True,          # 仅 HTTPS
    httponly=True,        # 防止 JavaScript 访问
    samesite='Lax'        # CSRF 保护
)
```

2. `resp.delete_cookie()` - 删除 Cookie
```python
resp = make_response("OK")
resp.delete_cookie('username')
```

3. `resp.set_data()` - 设置响应数据
```python
resp = make_response()
resp.set_data('{"status": "ok"}')
resp.content_type = "application/json"
```

---

### 实际应用场景

#### 场景1：设置自定义响应头（你的代码）
```python
@app.post("/analyze")
def analyze():
    result = analyze_text(text, top_n=top_n)
    resp = make_response(result, 200)
    resp.headers["X-Top-N"] = str(top_n)
    return resp
```

#### 场景2：设置 Cookie（登录）
```python
@app.post("/login")
def login():
    # 验证用户...
    resp = make_response({"message": "Login successful"}, 200)
    resp.set_cookie('session_token', token, max_age=3600, httponly=True)
    return resp
```

#### 场景3：文件下载
```python
@app.get("/download")
def download():
    csv_data = generate_csv()
    resp = make_response(csv_data)
    resp.headers["Content-Type"] = "text/csv"
    resp.headers["Content-Disposition"] = "attachment; filename=data.csv"
    return resp
```

#### 场景4：CORS 跨域支持
```python
@app.route("/api/data")
def api_data():
    resp = make_response({"data": "ok"}, 200)
    resp.headers["Access-Control-Allow-Origin"] = "*"
    resp.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
    return resp
```

#### 场景5：设置缓存头
```python
@app.get("/static-data")
def static_data():
    resp = make_response({"data": "cached"}, 200)
    resp.headers["Cache-Control"] = "public, max-age=3600"
    resp.headers["ETag"] = "abc123"
    return resp
```

#### 场景6：返回 XML 或其他格式
```python
@app.get("/xml")
def xml_response():
    xml_data = "<root><item>data</item></root>"
    resp = make_response(xml_data, 200)
    resp.content_type = "application/xml"
    return resp
```

---

### 与直接返回的对比

### 方式对比表

| 需求 | 直接返回 | `make_response` |
|------|---------|----------------|
| 简单响应 | ✅ `return "OK"` | ❌ 过度使用 |
| 设置状态码 | ✅ `return data, 200` | ✅ `make_response(data, 200)` |
| 设置响应头 | ❌ 不支持 | ✅ `resp.headers["X-Key"] = "value"` |
| 设置 Cookie | ❌ 不支持 | ✅ `resp.set_cookie(...)` |
| 动态构建响应 | ❌ 有限 | ✅ 完全控制 |
| 修改响应内容 | ❌ 不支持 | ✅ `resp.set_data(...)` |

---

### 完整示例：综合使用

```python
from flask import Flask, make_response, request
import json

app = Flask(__name__)

@app.post("/api/users")
def create_user():
    data = request.get_json()
    
    # 创建用户...
    user_id = 123
    
    # 创建响应
    resp = make_response({
        "id": user_id,
        "name": data["name"],
        "message": "User created"
    }, 201)  # 201 Created
    
    # 设置响应头
    resp.headers["X-User-ID"] = str(user_id)
    resp.headers["X-Request-ID"] = request.headers.get("X-Request-ID", "unknown")
    
    # 设置 Cookie
    resp.set_cookie(
        'user_session',
        f'session_{user_id}',
        max_age=3600,
        httponly=True,
        secure=True
    )
    
    # 设置 Content-Type（虽然 Flask 通常自动处理）
    resp.content_type = "application/json; charset=utf-8"
    
    return resp
```

---

### 注意事项

#### 1. 字典会自动转为 JSON
```python
resp = make_response({"key": "value"}, 200)
# Flask 会自动设置 Content-Type: application/json
```

#### 2. 字符串需要手动设置 Content-Type
```python
resp = make_response("<html>...</html>")
resp.content_type = "text/html"  # 需要手动设置
```

#### 3. 二进制数据
```python
resp = make_response(binary_data)
resp.content_type = "image/png"
```

#### 4. 在 `after_request` 中使用
```python
@app.after_request
def add_header(response):
    response.headers["X-Custom"] = "value"
    return response  # 必须返回 response 对象
```

---

### 总结

`make_response` 适用于需要精细控制响应的场景：
- ✅ 设置自定义响应头
- ✅ 设置 Cookie
- ✅ 自定义 Content-Type
- ✅ 动态构建响应
- ✅ 文件下载
- ✅ CORS 配置

简单场景可以直接返回数据或元组，无需使用 `make_response`。